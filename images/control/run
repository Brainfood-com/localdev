#!/usr/bin/env python

from __future__ import print_function

from collections import defaultdict
import docker
import dockerpty
import json
import os
import re
import shlex
import sys
from time import sleep
import yaml

map_term = os.environ['MAP_TERM']

matched = re.match('^([0-9]*):([0-9]*):(.*)$', map_term)
if matched:
    os.environ['COLUMNS'] = matched.group(1)
    os.environ['LINES'] = matched.group(2)
    os.environ['TERM'] = matched.group(3)

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def escape_compose_name(value):
    return re.sub('[^a-zA-Z0-9]+', '', value)

service_label_re = re.compile('^com\.brainfood\.docker\.localdev\.(target_pwd|target_user)(?:=(.*))?$')
tool_label_re = re.compile('com\.brainfood\.docker\.localdev\.tool\.([^=.]+)(?:\.(target_pwd|target_user))?(?:=(.*))?$')
class Service(object):
    def __init__(self, name):
        self.name = name
        self.target_pwd = None
        self.target_user = None
        self.tools = {}

    def absorbLabel(self, label):
        service_label_match = service_label_re.match(label)
        tool_label_match = tool_label_re.match(label)
        if service_label_match:
            self.__dict__[service_label_match.group(1)] = service_label_match.group(2)
        elif tool_label_match:
            tool_name = tool_label_match.group(1)
            tool = self.tools.setdefault(tool_name, ServiceTool(self, tool_name))
            tool.absorbLabel(tool_label_match.group(2), tool_label_match.group(3))

class Tool(object):
    def __init__(self, name):
        self.name = name

class ParseEnvironmentTool(Tool):
    def run(self, controller, cmd, args):
        if cmd is None:
            controller.run_tool('help', args)
        controller.parse_environment()
        controller.tools.default_factory = lambda: InvalidTool('missing')
        return controller.run_tool(cmd, args)

class InvalidTool(Tool):
    def run(self, controller, cmd, args):
        eprint('Could not find tool: %s' % (cmd))
        sys.exit(1)

class ComposeTool(Tool):
    def run(self, controller, cmd, args):
        return controller.compose_helper(cmd, args)

    def help(self, controller, cmd):
        return ['Call "docker-compose -f docker-compose.${cmd}.yml" ...']

class ExecTool(Tool):
    def run(self, controller, cmd, args):
        if len(args) == 0:
            args.append('bash')
        return controller.exec_helper(controller.project_container, '/', None, args)

    def help(self, controller, cmd):
        return ['Execute a command in the control container for this project.']

class HelpTool(Tool):
    def run(self, controller, cmd, args):
        controller.parse_environment()
        found_tools_by_tool = {}
        print('The following commands are available:')
        print()
        for tool_name, tool in controller.tools.items():
            found_tool = found_tools_by_tool.setdefault(tool, {'tool': tool, 'names': []})
            found_tool['names'].append(tool_name)

        max_name_length = 0
        for found_tool in found_tools_by_tool.values():
            names = found_tool['names']
            found_tool.pop('names')
            names.sort()
            found_tool['name'] = name = names.pop(0)
            if len(name) > max_name_length:
                max_name_length = len(name)
            found_tool['help'] = help = found_tool['tool'].help(controller, name)
            if len(names):
                help.append('Aliases: ' + ', '.join(names))

        found_tools = found_tools_by_tool.values()
        found_tools.sort(key=lambda found_tool: found_tool['name'])
        width = os.environ.get('COLUMNS', 80)
        leader = ' ' * (8 + max_name_length + 1)
        for found_tool in found_tools:
            name = found_tool['name']
            help = found_tool['help']
            line_to_print = '        %s%s ' % (name, ' ' * (max_name_length - len(name)))
            while len(help):
                help_words = help.pop(0).split()
                while len(help_words):
                    while len(help_words) and len(line_to_print) + 1 + len(help_words[0]) < width:
                        line_to_print = line_to_print + ' ' + help_words.pop(0)
                    if len(line_to_print):
                        print(line_to_print)
                    line_to_print = leader

        return {'ExitCode': 0}

    def help(self, controller, cmd):
        return ['Show what tools are available.']

class ServiceTool(Tool):
    def __init__(self, service, name):
        super(ServiceTool, self).__init__(name)
        self.service = service
        self._target_pwd = None
        self._target_user = None
        self.executable = name

    @property
    def target_pwd(self):
        return self._target_pwd or self.service.target_pwd

    @property
    def target_user(self):
        return self._target_user or self.service.target_user

    def absorbLabel(self, label, value):
        if label == 'target_pwd' or label == 'target_user':
            self.__dict__['_' + label] = value
        elif label is None and value:
            self.executable = value

    def run(self, controller, cmd, args):
        escaped_project_name = escape_compose_name(controller.vars['COMPOSE_PROJECT_NAME'])

        labels = {
            'com.docker.compose.project' : escaped_project_name,
            'com.brainfood.docker.localdev.tool.' + cmd: None,
        }
        tool_container = controller.find_container(labels)
        if not tool_container:
            controller.tools['dev'].run(controller, 'dev', ['up', '-d', self.service.name])
            sleep(1)
            tool_container = controller.find_container(labels)

        if not tool_container:
            eprint('Could not find tool: %s' % (cmd))
            sys.exit(1)

        executable = self.executable
        target_pwd = self.target_pwd
        target_user = self.target_user

        if target_pwd == 'relative':
            working_dir = '/srv/app' + controller._relative_dir
        elif target_pwd == 'image':
            working_dir = ''
        else:
            working_dir = '/'

        return controller.exec_helper(tool_container, working_dir, target_user, [executable] + args)

    def help(self, controller, cmd):
        return ['Run the command in the service.']

shell_var_re = re.compile('^([^=]+)=(.*)$')
class Controller():
    def __init__(self):
        self._docker = None
        self._project_container = None
        self._environment_parsed = False

        self._map_umask = os.environ['MAP_UMASK']
        self._map_pwd = os.environ['MAP_PWD']
        self._map_top_dir = os.environ['MAP_TOP_DIR']
        self._map_user = os.environ['MAP_USER']
        self._relative_dir = self._map_pwd[len(self._map_top_dir):]

        self.services = {}
        self.tools = defaultdict(lambda: ParseEnvironmentTool('parse-environment'))
        self.tools['dev'] = self.tools['prod'] = ComposeTool('compose')
        self.tools['exec'] = ExecTool('exec')
        self.tools['help'] = HelpTool('help')
        self.vars = {}

    def docker(self):
        if not self._docker:
            self._docker = docker.from_env()
        return self._docker

    def parse_yml(self, compose_yml):
        compose_data = yaml.load(compose_yml)

        for service_name, service_config in compose_data['services'].items():
            if 'labels' in service_config:
                service = self.services.setdefault(service_name, Service(service_name))
                for label_str in service_config['labels']:
                    service.absorbLabel(label_str)

                for tool_name, tool in service.tools.items():
                    self.tools[tool_name] = tool

    def parse_env(self, env):
        for line in shlex.split(env, True):
            shell_var_match = shell_var_re.match(line)
            if shell_var_match:
                self.vars[shell_var_match.group(1)] = shell_var_match.group(2)

    def find_container(self, labels):
        label_filters = []
        for label, value in labels.items():
            if value:
                label_filters.append(label + '=' + value)
            else:
                label_filters.append(label)

        found = self.docker().containers.list(all = True, filters = {'label': label_filters}, sparse = True)
        while len(found) > 1:
            found[0].remove(force = True)
            found.pop(0)

        if len(found) == 1:
            return found[0]

    @property
    def project_container(self):
        if self._project_container: return self._project_container

        labels = {
            'com.brainfood.docker.localdev.top_dir': self._map_top_dir,
            'com.brainfood.docker.localdev.map_user': self._map_user,
            'com.brainfood.docker.localdev.map_umask': self._map_umask,
        }

        container = self.find_container(labels)
        if container:
            container_image_hash = container.attrs['Image']

            if container.attrs['Image'] != 'localdev':
                container.remove(force = True)
            elif not 'localdev_default' in container.attrs['NetworkSettings']['Networks']:
                container.remove(force = True)
            else:
                self._project_container = container
                return container

        new_container_config = {
            'labels': labels,
            'network': 'localdev_default',
            'volumes': {
                self._map_top_dir: {'bind': self._map_top_dir, 'mode': 'rw'},
                '/var/run/docker.sock': {'bind': '/var/run/docker.sock', 'mode': 'rw'},
            },
        }

        new_container = self.docker().containers.create('localdev', detach = True, **new_container_config)
        new_container.start()
        self._project_container = new_container
        return new_container

    def parse_environment(self):
        if not self._environment_parsed:
            controller.parse_yml(os.environ.get('MAP_DEV_YML', ''))
            controller.parse_env(os.environ.get('MAP_ENV', ''))
            _environment_parsed = True

    def exec_helper(self, container, workdir, user, command):
        isatty = sys.stdout.isatty()
        api = self.docker().api
        result = api.exec_create(
            container.id,
            command,
            stdin = True,
            tty = isatty,
            user = user,
            workdir = workdir,
            environment = {
                'COLUMNS': os.environ.get('COLUMNS'),
                'LINES': os.environ.get('LINES'),
                'TERM': os.environ.get('TERM'),
            },
        )
        dockerpty.start_exec(api, result['Id'])
        return api.exec_inspect(result['Id'])

    def run_tool(self, cmd, args):
        return self.tools[cmd].run(self, cmd, args)

    def compose_helper(self, which, args):
        return self.exec_helper(self.project_container, self._map_top_dir, None, ['docker-compose', '-f', 'docker-compose.' + which + '.yml'] + args)

    def cmd(self, command):
        cmd = command.pop(0)
        return self.run_tool(cmd, command)

controller = Controller()

command = sys.argv[1:]
sys.exit(controller.cmd(command)['ExitCode'])
