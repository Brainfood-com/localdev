#!/usr/bin/env python

from __future__ import print_function

import docker
import dockerpty
import json
import os
import re
import shlex
import sys
from time import sleep
import yaml

map_term = os.environ['MAP_TERM']

matched = re.match('^([0-9]*):([0-9]*):(.*)$', map_term)
if matched:
    os.environ['COLUMNS'] = matched.group(1)
    os.environ['LINES'] = matched.group(2)
    os.environ['TERM'] = matched.group(3)

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def escape_compose_name(value):
    return re.sub('[^a-zA-Z0-9]+', '', value)

service_label_re = re.compile('^com\.brainfood\.docker\.localdev\.(target_pwd|target_user)(?:=(.*))?$')
tool_label_re = re.compile('com\.brainfood\.docker\.localdev\.tool\.([^=.]+)(?:\.(target_pwd|target_user))?(?:=(.*))?$')
class Service(object):
    def __init__(self, name):
        self.name = name
        self.target_pwd = None
        self.target_user = None
        self.tools = {}

    def absorbLabel(self, label):
        service_label_match = service_label_re.match(label)
        tool_label_match = tool_label_re.match(label)
        if service_label_match:
            self.__dict__[service_label_match.group(1)] = service_label_match.group(2)
        elif tool_label_match:
            tool_name = tool_label_match.group(1)
            tool = self.tools.setdefault(tool_name, ServiceTool(self, tool_name))
            tool.absorbLabel(tool_label_match.group(2), tool_label_match.group(3))

class Tool(object):
    def __init__(self, name):
        self.name = name

class ServiceTool(Tool):
    def __init__(self, service, name):
        super(ServiceTool, self).__init__(name)
        self.service = service
        self._target_pwd = None
        self._target_user = None
        self.executable = name

    @property
    def target_pwd(self):
        return self._target_pwd or self.service.target_pwd

    @property
    def target_user(self):
        return self._target_user or self.service.target_user

    def absorbLabel(self, label, value):
        if label == 'target_pwd' or label == 'target_user':
            self.__dict__['_' + label] = value
        elif label is None and value:
            self.executable = value

shell_var_re = re.compile('^([^=]+)=(.*)$')
class Controller():
    def __init__(self):
        self._docker = None
        self._project_container = None
        self._environment_parsed = False

        self._map_umask = os.environ['MAP_UMASK']
        self._map_pwd = os.environ['MAP_PWD']
        self._map_top_dir = os.environ['MAP_TOP_DIR']
        self._map_user = os.environ['MAP_USER']
        self._relative_dir = self._map_pwd[len(self._map_top_dir):]

        self.services = {}
        self.tools = {}
        self.vars = {}

    def docker(self):
        if not self._docker:
            self._docker = docker.from_env()
        return self._docker

    def parse_yml(self, compose_yml):
        compose_data = yaml.load(compose_yml)

        for service_name, service_config in compose_data['services'].items():
            if 'labels' in service_config:
                service = self.services.setdefault(service_name, Service(service_name))
                for label_str in service_config['labels']:
                    service.absorbLabel(label_str)

                for tool_name, tool in service.tools.items():
                    self.tools[tool_name] = tool

    def parse_env(self, env):
        for line in shlex.split(env, True):
            shell_var_match = shell_var_re.match(line)
            if shell_var_match:
                self.vars[shell_var_match.group(1)] = shell_var_match.group(2)

    def find_container(self, labels):
        label_filters = []
        for label, value in labels.items():
            if value:
                label_filters.append(label + '=' + value)
            else:
                label_filters.append(label)

        found = self.docker().containers.list(all = True, filters = {'label': label_filters}, sparse = True)
        while len(found) > 1:
            found[0].remove(force = True)
            found.pop(0)

        if len(found) == 1:
            return found[0]

    @property
    def project_container(self):
        if self._project_container: return self._project_container

        labels = {
            'com.brainfood.docker.localdev.top_dir': self._map_top_dir,
            'com.brainfood.docker.localdev.map_user': self._map_user,
            'com.brainfood.docker.localdev.map_umask': self._map_umask,
        }

        container = self.find_container(labels)
        if container:
            container_image_hash = container.attrs['Image']

            if container.attrs['Image'] != 'localdev':
                container.remove(force = True)
            elif not 'localdev_default' in container.attrs['NetworkSettings']['Networks']:
                container.remove(force = True)
            else:
                self._project_container = container
                return container

        new_container_config = {
            'labels': labels,
            'network': 'localdev_default',
            'volumes': {
                self._map_top_dir: {'bind': self._map_top_dir, 'mode': 'rw'},
                '/var/run/docker.sock': {'bind': '/var/run/docker.sock', 'mode': 'rw'},
            },
        }

        new_container = self.docker().containers.create('localdev', detach = True, **new_container_config)
        new_container.start()
        self._project_container = new_container
        return new_container

    def parse_environment(self):
        if not self._environment_parsed:
            controller.parse_yml(os.environ.get('MAP_DEV_YML', ''))
            controller.parse_env(os.environ.get('MAP_ENV', ''))
            _environment_parsed = True

    def exec_helper(self, container, workdir, user, command):
        isatty = sys.stdout.isatty()
        api = self.docker().api
        result = api.exec_create(
            container.id,
            command,
            stdin = True,
            tty = isatty,
            user = user,
            workdir = workdir,
            environment = {
                'COLUMNS': os.environ.get('COLUMNS'),
                'LINES': os.environ.get('LINES'),
                'TERM': os.environ.get('TERM'),
            },
        )
        dockerpty.start_exec(api, result['Id'])
        return api.exec_inspect(result['Id'])

    def run_tool(self, cmd, args):
        self.parse_environment()

        if not cmd in self.tools:
            eprint('Could not find tool: %s' % (cmd))
            sys.exit(1)

        tool = self.tools[cmd]
        escaped_project_name = escape_compose_name(self.vars['COMPOSE_PROJECT_NAME'])

        labels = {
            'com.docker.compose.project' : escaped_project_name,
            'com.brainfood.docker.localdev.tool.' + cmd: None,
        }
        tool_container = self.find_container(labels)
        if not tool_container:
            self.compose_helper('dev', ['up', '-d', tool.service.name])
            sleep(1)
            tool_container = self.find_container(labels)

        if not tool_container:
            eprint('Could not find tool: %s' % (cmd))
            sys.exit(1)

        executable = tool.executable
        target_pwd = tool.target_pwd
        target_user = tool.target_user

        if target_pwd == 'relative':
            working_dir = '/srv/app' + self._relative_dir
        elif target_pwd == 'image':
            working_dir = ''
        else:
            working_dir = '/'

        return self.exec_helper(tool_container, working_dir, target_user, [executable] + args)

    def compose_helper(self, which, args):
        return self.exec_helper(self.project_container, self._map_top_dir, None, ['docker-compose', '-f', 'docker-compose.' + which + '.yml'] + args)

    def cmd(self, command):
        cmd = command.pop(0)
        if not cmd or cmd == 'help':
            print('You need help')
        elif cmd == 'exec':
            if len(command) == 0:
                command.append('bash')
            return self.exec_helper(self.project_container, '/', None, command)
            pass
        elif cmd == 'dev' or cmd == 'prod':
            return self.compose_helper(cmd, command)
        else:
            return self.run_tool(cmd, command)

controller = Controller()

command = sys.argv[1:]
sys.exit(controller.cmd(command)['ExitCode'])
