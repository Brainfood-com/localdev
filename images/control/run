#!/usr/bin/env python

from __future__ import print_function

from collections import defaultdict
import docker
import dockerpty
import json
import os
import re
import shlex
import sys
from time import sleep
import yaml

map_term = os.environ['MAP_TERM']

matched = re.match('^([0-9]*):([0-9]*):(.*)$', map_term)
if matched:
    os.environ['COLUMNS'] = matched.group(1)
    os.environ['LINES'] = matched.group(2)
    os.environ['TERM'] = matched.group(3)

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def escape_compose_name(value):
    return re.sub('[^a-zA-Z0-9]+', '', value)

service_label_re = re.compile('^com\.brainfood\.docker\.localdev\.(target_pwd|target_user)(?:=(.*))?$')
tool_label_re = re.compile('com\.brainfood\.docker\.localdev\.tool\.([^=.]+)(?:\.(target_pwd|target_user))?(?:=(.*))?$')
class Service(object):
    def __init__(self, name, project):
        self.name = name
        self.project = project
        self.target_pwd = None
        self.target_user = None
        self.tools = {}

    def absorbLabel(self, label):
        service_label_match = service_label_re.match(label)
        tool_label_match = tool_label_re.match(label)
        if service_label_match:
            self.__dict__[service_label_match.group(1)] = service_label_match.group(2)
        elif tool_label_match:
            tool_name = tool_label_match.group(1)
            tool = self.tools.setdefault(tool_name, ServiceTool(tool_name, self))
            tool.absorbLabel(tool_label_match.group(2), tool_label_match.group(3))

class Tool(object):
    def __init__(self, name):
        self.name = name

class ControllerTool(Tool):
    def __init__(self, name, controller):
        super(ControllerTool, self).__init__(name)
        self.controller = controller

class InvalidTool(Tool):
    def run(self, cmd, args):
        eprint('Could not find tool: %s' % (cmd))
        sys.exit(1)

class ComposeTool(ControllerTool):
    def run(self, cmd, args):
        return self.controller.exec_helper(self.controller.project.container, workdir = self.controller.project.top_dir, command = ['docker-compose', '-f', 'docker-compose.' + cmd + '.yml'] + args)

    def help(self, cmd):
        return ['Call "docker-compose -f docker-compose.${cmd}.yml" ...']

class ExecTool(ControllerTool):
    def run(self, cmd, args):
        if len(args) == 0:
            args.append('bash')
        return self.controller.project.run(workdir = '/', command = args)

    def help(self, cmd):
        return ['Execute a command in the control container for this project.']

class HelpTool(ControllerTool):
    def run(self, cmd, args):
        self.controller.project.parse_environment()
        found_tools_by_tool = {}
        print('The following commands are available:')
        print()
        for tool_name, tool in self.controller.tools.items() + self.controller.project.tools.items():
            found_tool = found_tools_by_tool.setdefault(tool, {'tool': tool, 'names': []})
            found_tool['names'].append(tool_name)

        max_name_length = 0
        for found_tool in found_tools_by_tool.values():
            names = found_tool['names']
            found_tool.pop('names')
            names.sort()
            found_tool['name'] = name = names.pop(0)
            if len(name) > max_name_length:
                max_name_length = len(name)
            found_tool['help'] = help = found_tool['tool'].help(name)
            if len(names):
                help.append('Aliases: ' + ', '.join(names))

        found_tools = found_tools_by_tool.values()
        found_tools.sort(key=lambda found_tool: found_tool['name'])
        width = os.environ.get('COLUMNS', 80)
        leader = ' ' * (8 + max_name_length + 1)
        for found_tool in found_tools:
            name = found_tool['name']
            help = found_tool['help']
            line_to_print = '        %s%s ' % (name, ' ' * (max_name_length - len(name)))
            while len(help):
                help_words = help.pop(0).split()
                while len(help_words):
                    while len(help_words) and len(line_to_print) + 1 + len(help_words[0]) < width:
                        line_to_print = line_to_print + ' ' + help_words.pop(0)
                    if len(line_to_print):
                        print(line_to_print)
                    line_to_print = leader

        return {'ExitCode': 0}

    def help(self, cmd):
        return ['Show what tools are available.']

class ServiceTool(Tool):
    def __init__(self, name, service):
        super(ServiceTool, self).__init__(name)
        self.service = service
        self._target_pwd = None
        self._target_user = None
        self.executable = name

    @property
    def target_pwd(self):
        return self._target_pwd or self.service.target_pwd

    @property
    def target_user(self):
        return self._target_user or self.service.target_user

    def absorbLabel(self, label, value):
        if label == 'target_pwd' or label == 'target_user':
            self.__dict__['_' + label] = value
        elif label is None and value:
            self.executable = value

    def run(self, cmd, args):
        project = self.service.project
        controller = project.controller
        escaped_project_name = escape_compose_name(project.vars['COMPOSE_PROJECT_NAME'])

        labels = {
            'com.docker.compose.project' : escaped_project_name,
            'com.brainfood.docker.localdev.tool.' + cmd: None,
        }
        tool_container = controller.find_container(labels)
        if not tool_container:
            controller.tools['dev'].run('dev', ['up', '-d', self.service.name])
            sleep(1)
            tool_container = controller.find_container(labels)

        if not tool_container:
            eprint('Could not find tool: %s' % (cmd))
            sys.exit(1)

        executable = self.executable
        target_pwd = self.target_pwd
        target_user = self.target_user

        if target_pwd == 'relative':
            working_dir = '/srv/app' + controller._relative_dir
        elif target_pwd == 'image':
            working_dir = ''
        else:
            working_dir = '/'

        return controller.exec_helper(container = tool_container, workdir = working_dir, user = target_user, command = [executable] + args)

    def help(self, cmd):
        return ['Run the command in the service.']

shell_var_re = re.compile('^([^=]+)=(.*)$')
class Project(object):
    def __init__(self, controller, top_dir):
        self.controller = controller
        self.top_dir = top_dir
        self._container = None
        self._services = {}
        self._tools = {}
        self._vars = {}
        self._environment_parsed = False

    @property
    def services(self):
        self.parse_environment()
        return self._services

    @property
    def vars(self):
        self.parse_environment()
        return self._vars

    @property
    def tools(self):
        self.parse_environment()
        return self._tools

    def parse_environment(self):
        if self._environment_parsed:
            return

        compose_data = yaml.load(os.environ.get('MAP_DEV_YML', ''))

        for service_name, service_config in compose_data['services'].items():
            if 'labels' in service_config:
                service = self._services.setdefault(service_name, Service(service_name, self))
                for label_str in service_config['labels']:
                    service.absorbLabel(label_str)

                for tool_name, tool in service.tools.items():
                    self._tools[tool_name] = tool

        for line in shlex.split(os.environ.get('MAP_ENV', ''), True):
            shell_var_match = shell_var_re.match(line)
            if shell_var_match:
                self._vars[shell_var_match.group(1)] = shell_var_match.group(2)

        self._environment_parsed = True

    @property
    def container(self):
        if self._container: return self._container

        labels = {
            'com.brainfood.docker.localdev.top_dir': self.top_dir,
            'com.brainfood.docker.localdev.map_user': self.controller._map_user,
            'com.brainfood.docker.localdev.map_umask': self.controller._map_umask,
        }

        container = self.controller.find_container(labels)
        if container:
            container_image_hash = container.attrs['Image']

            if container.attrs['Image'] != 'localdev':
                container.remove(force = True)
            elif not 'localdev_default' in container.attrs['NetworkSettings']['Networks']:
                container.remove(force = True)
            else:
                self._container = container
                return container

        container_config = {
            'labels': labels,
            'network': 'localdev_default',
            'volumes': {
                self.top_dir: {'bind': self.top_dir, 'mode': 'rw'},
                '/var/run/docker.sock': {'bind': '/var/run/docker.sock', 'mode': 'rw'},
            },
        }

        container = self.controller.docker.containers.create('localdev', detach = True, **container_config)
        container.start()
        self._container = container
        return container

    def run(self, command = None, workdir = os.environ['MAP_PWD']):
        return self.controller.exec_helper(self.container, workdir = workdir, command = command)

class Controller():
    def __init__(self):
        self._docker = None

        self.project = Project(self, os.environ['MAP_TOP_DIR'])

        self._map_umask = os.environ['MAP_UMASK']
        self._map_pwd = os.environ['MAP_PWD']
        self._map_user = os.environ['MAP_USER']
        self._relative_dir = self._map_pwd[len(self.project.top_dir):]

        self.tools = {}
        self.tools['dev'] = self.tools['prod'] = ComposeTool('compose', self)
        self.tools['exec'] = ExecTool('exec', self)
        self.tools['help'] = HelpTool('help', self)

    @property
    def docker(self):
        if not self._docker:
            self._docker = docker.from_env()
        return self._docker

    def find_container(self, labels):
        label_filters = []
        for label, value in labels.items():
            if value:
                label_filters.append(label + '=' + value)
            else:
                label_filters.append(label)

        found = self.docker.containers.list(all = True, filters = {'label': label_filters}, sparse = True)
        while len(found) > 1:
            found[0].remove(force = True)
            found.pop(0)

        if len(found) == 1:
            return found[0]

    def exec_helper(self, container, workdir = '/', user = None, command = []):
        isatty = sys.stdout.isatty()
        api = self.docker.api
        result = api.exec_create(
            container.id,
            command,
            stdin = True,
            tty = isatty,
            user = user,
            workdir = workdir,
            environment = {
                'COLUMNS': os.environ.get('COLUMNS'),
                'LINES': os.environ.get('LINES'),
                'TERM': os.environ.get('TERM'),
            },
        )
        dockerpty.start_exec(api, result['Id'], isatty)
        return api.exec_inspect(result['Id'])

    def run_tool(self, cmd, args):
        if cmd in self.tools:
            tool = self.tools[cmd]
        else:
            tool = self.project.tools[cmd]
        return tool.run(cmd, args)

    def cmd(self, command):
        cmd = command.pop(0)
        return self.run_tool(cmd, command)

controller = Controller()

command = sys.argv[1:]
sys.exit(controller.cmd(command)['ExitCode'])
